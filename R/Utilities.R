################################################################################
#
#   iprior: Linear Regression using I-priors
#   Copyright (C) 2016  Haziq Jamil
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
################################################################################

triangIndex <- function(k){
  # Function to list row and column index of upper triangular matrix including
  # diagonals.
  w <- 1:k
  cbind(
    row = rep(w, times = length(w):1 ) ,
    col = unlist(lapply(1:length(w), function(x) c(NA,w)[-(0:x)]))
  )
}

is.ipriorMod <- function(x) inherits(x, "ipriorMod")

is.ipriorKernel <- function(x) inherits(x, "ipriorKernel")

testXForm <- function(x) {
  # Tests whether object x is a data frame fitted using formula interface.
  xform <- FALSE
  if (length(x) == 1) {
    if (is.data.frame(x[[1]])) {
      xform <- !is.null(attr(x[[1]], "terms"))
    }
  }
  xform
}

isHOrd <- function(x) {
  # Tests whether x contains ^ indicating higher order term.
  grepl("\\^", x)
}

whereOrd <- function(x) {
  # Index of non-higher order terms.
  grep("\\^", x, invert = TRUE)
}

lenHOrd <- function(x) {
  # How many higher order terms have been specified?
  length(grep("\\^", x))
}

splitHOrd <- function(x) {
  # Gets the level 1 index and the power it is raised to
  strsplit(x, "\\^")[[1]]
}

isCan <- function(x) x == "Canonical"

isPea <- function(x) x == "Pearson"

isFBM <- function(x) x == "FBM"

canPeaFBM <- function(x, kernel, gamma, y) {
  if (isCan(kernel)) res <- fnH2(x, y)
  if (isPea(kernel)) res <- fnH1(x, y)
  if (isFBM(kernel)) res <- fnH3(x, y, gamma)
  res
}

hMatList <- function(x, kernel, intr, no.int, gamma,
                     xstar = vector("list", p)) {
  # Helper function for creation of list of H matrices. Used in Kernel_loader.r
  # and predict.R
  p <- length(x)
  H <- mapply(canPeaFBM, x = x, kernel = as.list(kernel),
              gamma = gamma, y = xstar, SIMPLIFY = FALSE)
  	if (!is.null(intr)) {
	  # Add in interactions, if any.
		for (j in 1:no.int) {
			H[[p + j]] <- H[[intr[1, j]]] * H[[intr[2, j]]]
			class(H[[p + j]]) <- paste(class(H[[intr[1,j]]]), class(H[[intr[2,j]]]),
			                           sep = " x ")
		}
	}
	H
}

indxFn <- function(k) {
  # Indexer helper function used to create indices for H2l. Note: intr, ind1 and
  # ind2 are created in kernL().
	ind.int1 <- intr[1, ] == k; ind.int2 <- intr[2, ] == k	# locating var/kernel matrix
	ind.int <- which(ind.int1 | ind.int2)  # of interactions (out of 1:no.int)
	k.int <- ind.int + p	# which kernel matrix has interactions involves k
	k.int.lam <- c(intr[1, ][ind.int2], intr[2, ][ind.int1])	# which has interaction with k?
	nok <- (1:p)[-k]	# all variables excluding k
	k.noint <- which(!(ind.int1 | ind.int2)) + p	# the opposite of k.int

	# P.mat %*% R.mat + R.mat %*% P.mat indices ----------------------------------
	za <- which((ind1 %in% k & ind2 %in% nok) | (ind2 %in% k & ind1 %in% nok))
	grid.PR <- expand.grid(k.int, nok)
	zb <- which(	(ind1 %in% grid.PR[,1] & ind2 %in% grid.PR[,2]) |
					(ind2 %in% grid.PR[,1] & ind1 %in% grid.PR[,2])
	)
	grid.PR.lam <- expand.grid(k.int.lam, nok)

	# P.mat %*% U.mat + U.mat %*% P.mat indices ----------------------------------
	grid.PU1 <- expand.grid(k, k.noint)
	zc <- which((ind1 %in% grid.PU1[,1] & ind2 %in% grid.PU1[,2]) |
					    (ind2 %in% grid.PU1[,1] & ind1 %in% grid.PU1[,2]))
	grid.PU2 <- expand.grid(k.int, k.noint)
	zd <- apply(grid.PU2, 1, findH2, ind1 = ind1, ind2 = ind2)
	grid.PU.lam <- expand.grid(k.int.lam, k.noint)

	# P.mat %*% P.mat indices ----------------------------------------------------
	grid.Psq <- t(combn(c(k, k.int), 2))
	ze <- apply(grid.Psq, 1, findH2, ind1 = ind1, ind2 = ind2 )
	grid.Psq.lam <- NULL
	if (length(k.int.lam) > 0) grid.Psq.lam <- t(combn(c(0, k.int.lam), 2))

	list(
	    k.int     = k.int,
	    k.int.lam = k.int.lam,
			PRU       = c(za,zc,zb,zd),
			PRU.lam1  = c(rep(0, length(nok) + length(k.noint)),
			            grid.PR.lam[,1],
			            grid.PU.lam[,1]),
			PRU.lam2  = c(nok, k.noint, grid.PR.lam[,2], grid.PU.lam[,2]),
			Psq       = c(k, k.int),
			Psq.lam   = k.int.lam,
			P2        = ze,
			P2.lam1   = grid.Psq.lam[,1],
			P2.lam2   = grid.Psq.lam[,2]
	)
}

findH2 <- function(z, ind1, ind2){
  # This function finds position of H2 (cross-product terms of H). Used in
  # indxFn()
  x <- z[1]; y <- z[2]
  which((ind1 == x & ind2 == y) | (ind2 == x & ind1 == y))
}

# flatten <- function(x) {
	# len <- sum(rapply(x, function(x) 1L))
	# y <- vector("list", len)
	# i <- 0L
	# rapply(x, function(x) { i <<- i+1L; y[[i]] <<- x })
	# y
# }

sigma.ipriorMod <- function(object, ...) object$sigma

.onUnload <- function(libpath) {
  # Whenever you use C++ code in your package, you need to clean up after
  # yourself when your package is unloaded.
  library.dynam.unload("iprior", libpath)
}

# Hacky way to pass R CMD CHECK "no visible binding" note ----------------------
globalVariables(c("BlockB", "BlockBstuff", "Hl", "Hlam.mat", "Pl", "Psql", "Sl",
                  "V", "Var.Y.inv", "VarY.inv", "W.hat", "Y", "alpha",
                  "force.nlm", "force.regEM", "hlamFn", "ind1", "ind2", "intr",
                  "ipriorEM.env", "l", "lambda", "maxit", "model", "n", "nlm",
                  "no.int", "one.lam", "p", "parsm", "psi", "r", "report", "s",
                  "stop.crit", "theta", "u", "w.hat", "x", "x0"))
