% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iprior.R
\name{iprior}
\alias{iprior}
\alias{iprior.default}
\alias{iprior.formula}
\alias{iprior.ipriorKernel}
\alias{iprior.ipriorMod}
\title{Fit an I-prior regression model}
\usage{
\method{iprior}{default}(y, ..., model = list(), control = list())

\method{iprior}{formula}(formula, data = parent.frame(), model = list(),
  control = list(), ...)

\method{iprior}{ipriorKernel}(object, control = list(), ...)

\method{iprior}{ipriorMod}(object, control = list(), ...)
}
\arguments{
\item{y}{Vector of response variables.}

\item{...}{Only used for when fitting using non-formula, enter the variables
(vectors or matrices) separated by commas. No other options applicable here.}

\item{model}{List of model options. Not used for \code{ipriorKernel} or
 \code{ipriorModel} objects. Available options are:
 \describe{\item{\code{kernel}}{Vector of character strings of either
 \code{"Canonical"}, \code{"FBM"}, or \code{"Pearson"}. Defaults to
 \code{"Canonical"} for continuous variables, and \code{"Pearson"} for factor
 type objects.} \item{\code{Hurst}}{The value of the Hurst coefficient when
 using the \code{FBM} kernel. This is a value between 0 and 1. Defaults to
 0.5.}\item{\code{order}}{Character vector of length equal to the number of
 explanatory variables used, indicating specification of higher order scale
 parameters. The syntax is \code{"a^b"}, for parameter \code{a} raised to the
 power \code{b}. For regular order terms, then just input "a".}
 \item{\code{parsm}}{Logical, defaults to \code{TRUE}. Set to \code{FALSE} to
 assign one scale parameter for all kernel matrices.}
 \item{\code{one.lam}}{Logical, defaults to \code{FALSE}. Only relevant when
 using the formula call. Should all the variable share the same scale
 parameter?}}

 These options are also available, but are only relevant when calling using
 non-formula: \describe{\item{\code{yname}}{Character vector to set the name
 of the response variable. It is set to the object name which contains the
 response variables by default.} \item{\code{xname}}{Character vector to set
 the name of the explanatory variables. This is also set to the object name
 by default.} \item{\code{interactions}}{Character vector to specify the
 interaction terms. When using formulas, this is specified automatically.
 Syntax is \code{"a:b"} to indicate variable \code{a} interacts with variable
 \code{b}.}}}

\item{control}{(optional) List of control options for EM algorithm and
output.}

\item{formula}{The formula to fit when using formula interface.}

\item{data}{Data frame containing variables when using formula interface.}

\item{object}{This is either an object of class formula (when fitting using
formula interface), \code{ipriorKernel} or \code{ipriorModel}. When left
\code{NULL}, then \code{y} must be used, along with the
covariates/independent variables.}
}
\value{
An object of class \code{ipriorMod}.
}
\description{
Description
}
\details{
Details
}
\section{Methods (by class)}{
\itemize{
\item \code{ipriorKernel}: Takes in object of type \code{ipriorKernel} and estimates
the parameters of the model via the EM algorithm.

\item \code{ipriorMod}: Re-run or continue running the EM algorithm from last
attained parameter values in object \code{ipriorMod}.
}}
\examples{
# Formula based input
(mod.stackf <- iprior(stack.loss ~ Air.Flow + Water.Temp + Acid.Conc.,
                      data = stackloss))
mod.toothf <- iprior(len ~ supp * dose, data = ToothGrowth)
summary(mod.toothf)

# Non-formula based input
mod.stacknf <- iprior(y = stackloss$stack.loss,
                      Air.Flow = stackloss$Air.Flow,
                      Water.Temp = stackloss$Water.Temp,
                      Acid.Conc. = stackloss$Acid.Conc.)
mod.toothnf <- iprior(y = ToothGrowth$len,
                      supp = ToothGrowth$supp,
                      dose = ToothGrowth$dose,
                      model = list(interactions = "1:2"))

# Formula based model option one.lam = TRUE
# Sets a single scale parameter for all variables
modf <- iprior(stack.loss ~ ., data = stackloss, model = list(one.lam = TRUE))
modnf <- iprior(y = stackloss$stack.loss, x = stackloss[1:3])

}

